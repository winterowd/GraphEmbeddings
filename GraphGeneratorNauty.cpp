

#include "GraphGeneratorNauty.h"

extern "C" {
int
GENG_MAIN(int argc, char *argv[]);
}

#include <boost/program_options.hpp>
namespace po = boost::program_options;

/// constructor which receives command line arguments from user
GraphGeneratorNauty::GraphGeneratorNauty(int argc, char *argv[]) :
    Parameters(argc, argv),
    fp(NULL)
{}

/// Set up geng argument list.  The 0-th argument is the command name. There must be a NULL at the end.
void GraphGeneratorNauty::Generate()
{

    std::vector<std::string> arguments;

    arguments.push_back("geng");
    if (!this->Parameters.AllowDisconnected())
        arguments.push_back("-c");

    for (int i=2; i<=this->Parameters.GetN(); ++i)
    {
        arguments.push_back(std::to_string(i));

        std::string filename = "graphs_g6_";
        if (!this->Parameters.AllowDisconnected())
            filename += "connected_";
        filename += "order_"+std::to_string(i)+".dat";

        arguments.push_back(filename);

        std::vector<char*> argv;
        for (const auto& arg: arguments)
            argv.push_back((char*)arg.data());
        argv.push_back(nullptr);

        /// call routine which reads in graphs in filename and then generates rooted graphs
        if (this->Parameters.GenerateTwoRooted())
            this->GenerateTwoRootedFixedOrder(i, filename, this->Parameters.IsVerbose());
        else /// otherwise generate connected graphs
            GENG_MAIN(argv.size()-1,argv.data());

        arguments.pop_back();
        arguments.pop_back();

    }

}

/// test routine for relabeling
void GraphGeneratorNauty::TestRelabeling(int n, std::string inputFilename)
{
    this->N = n;

    this->GetAllPossiblePairsForRootedVertices();

    /// read in a random graph (should match order n)
    int m = SETWORDSNEEDED(this->N);

    FILE *fp = fopen(inputFilename.c_str(), "r");

    if (fp!=NULL)
        std::cout << "TestRelabeling: Successfully opened " << inputFilename << std::endl;
    else
        throw std::invalid_argument("TestRelabeling: Error opening "+inputFilename);

    DYNALLSTAT(graph, g, g_sz);
    DYNALLOC2(graph, g, g_sz, n, m, "malloc");

    graph *gtemp = readg(fp,g,m,&m,&n);

    GraphContainer refGraph(this->N, m, g);

    std::vector<int> newLabels(this->N, -1);
    for (int i=0; i<this->RootedVertexNumbers.size(); ++i)
    {
        this->ProduceNewLabelingGivenRootedVertices(this->RootedVertexNumbers[i], newLabels, true);
        GraphContainer tempGraph(refGraph);
        tempGraph.RelabelVertices(newLabels);
    }

    DYNFREE(g,g_sz);
    fclose(fp);
}

/// sets up the nauty data structures lab and ptn according to our vertex coloring convention (N vertices with 3 colors, rooted vertices being colors 0 and 1 and ALWAYS assigned labels 0 and 1!!!!!)
/// c: C-style array of N integers specifying the color of each vertex i.e. c_j gives the color of vertex labeled j (should be 0, 1, or 2)
/// lab: C-style array of N integers specifying vertex labels
/// ptn: C-style array of N integers specifying and partition of the vertex labels into colors
void GraphGeneratorNauty::SetColoredPartition(int* c, int* lab, int* ptn)
{
    /* loop over all colors to fill it */
    int cur_index = 0;
    for (int i = 0; i<3; i++) /// loop over colors
    {
        for (int j = 0; j<this->N; j++) /// loop over vertex labels
        {
            if (c[j] == i)
            {
                lab[cur_index] = j;
                ptn[cur_index] = 1;
                cur_index++;
            }
        }

        if (cur_index > 0) /// partition ends with a zero
        {
            ptn[cur_index - 1] = 0;
        }
    }
}

/// generate rooted graphs from list of connected graphs of order N
/// read in graphs which are assumed to be generated by geng and enumerate the two-rooted graphs
/// generate all pairs of vertices which will be colors 0 and 1 (rooted graphs). Relabel the graph so that the two rooted vertices will have labels 0 and 1, respectively
/// call densenauty to get canonical ordering of vertices of color 2 (rooted vertices map to themselves)
/// compare adjacency matrices of previously generated rooted graphs coming from a single unrooted graph to see if we have generated a new rooted graph
/// n: number of vertices
/// inputFilename: name of the file containing the graphs in g6 format
/// verbose: flag for verbosity
void GraphGeneratorNauty::GenerateTwoRootedFixedOrder(int n, std::string inputFilename, bool verbose)
{
    /// set up auxiliary variables for NAUTY
    this->N = n; /// set graph size
    this->MWords = SETWORDSNEEDED(this->N); /// set number of words

    static DEFAULTOPTIONS_GRAPH(options); /// options
    options.defaultptn = false; /// color the vertices

    nauty_check(WORDSIZE, this->N, this->MWords, NAUTYVERSIONID); /// check if everything is ok

    this->fp = fopen(inputFilename.c_str(), "r"); /// open file containing graphs of a fixed order from which we will generate two-rooted graphs
    if (this->fp!=NULL)
        std::cout << "GenerateTwoRootedFixedOrder: Successfully opened " << inputFilename << std::endl;
    else
        throw std::invalid_argument("GenerateTwoRootedFixedOrder: Error opening "+inputFilename);

    //// output file stream for rooted graphs
    std::string outputFilename = "graphs_g6_rooted_";
    if (!this->Parameters.AllowDisconnected())
        outputFilename += "connected_";
    outputFilename += "order_"+std::to_string(this->N)+".dat";
    std::ofstream g6File(outputFilename.c_str());

    /// generate all pairs of vertices given order N
    this->GetAllPossiblePairsForRootedVertices();

    /// declare nauty data structures
    DYNALLSTAT(graph, g, g_sz); /// declare graph
    DYNALLSTAT(graph, g_temp, g_temp_sz); /// declare tempm graph
    DYNALLSTAT(int, lab, lab_sz); /// ref label
    DYNALLSTAT(int, lab_cg, lab_cg_sz); /// label for canonical form (WILL CHANGE)
    DYNALLSTAT(int, ptn, ptn_sz); /// partition for coloring
    DYNALLSTAT(int, orbits, orbits_sz); /// orbits when calling densenauty
    statsblk stats; /// status

    /// allocate nauty data structures
    DYNALLOC2(graph, g, g_sz, this->N, this->MWords, "malloc");
    DYNALLOC2(graph, g_temp, g_temp_sz, this->N, this->MWords, "malloc");
    DYNALLOC2(int, lab, lab_sz, this->N, this->MWords, "malloc");
    DYNALLOC2(int, lab_cg, lab_cg_sz, this->N, this->MWords, "malloc");
    DYNALLOC2(int, ptn, ptn_sz, this->N, this->MWords, "malloc");
    DYNALLOC2(int, orbits, orbits_sz, this->N, this->MWords, "malloc");

    int *c = (int*)malloc(this->N * sizeof(int)); /// colors of vertices (0, 1, 2)
    c[0] = 0; /// vertex 0 always color 0
    c[1] = 1; /// vertex 1 always color 1
    for (int i=2; i<this->N; ++i) /// all other vertices color 2
        c[i] = 2;
    this->SetColoredPartition(c, lab, ptn); /// set up reference coloring

    GraphContainer refContainer(this->N, this->MWords); /// container for graphs
    std::vector<int> tempLabels(this->N, -1); /// for relabeling graphs (color 0 vertex always labeled 0 and color 1 vertex always labeled 1)
    int count = 0; /// initialize counter
    while (1) /// read graphs in file (ASSUME THEY ARE ALL OF THE SAME ORDER N!)
    {
        graph *g1 = this->GetNextGraph(g);
        if (g1 == NULL)
            break;
        count++; /// increment counter

        std::vector<GraphContainer> rootedGraphList; /// holds the list of rooted graphs produced from a single connected graph (one line of file produced by geng)

        refContainer.SetGraphFromDenseNauty(g); /// setup container from nauty dense format

        for (int i=0; i<this->RootedVertexNumbers.size(); ++i) /// loop over pairs of rooted vertices
        {
            this->ProduceNewLabelingGivenRootedVertices(this->RootedVertexNumbers[i], tempLabels); /// get new graph
            GraphContainer tempGraph(refContainer); /// copy constructor

            tempGraph.RelabelVertices(tempLabels); /// relabel graph
            tempGraph.GetDenseNautyFromGraph(g_temp); /// get dense nauty format of relabeled graph
            this->SetColoredPartition(c, lab_cg, ptn); /// set coloring (will be written over in call to densenauty)

            /// call densenauty
            densenauty(g_temp, lab_cg, ptn, orbits, &options, &stats, this->MWords, this->N, nullptr);

            tempGraph.ColoredCanonicalRelabeling(lab, lab_cg, 0, 1, true); /// relabel according to canonical labeling returned from densenauty

            /// add tempGraph to rootedGraphList if not already in the list (TODO)
            if (std::find(rootedGraphList.begin(), rootedGraphList.end(), tempGraph) == rootedGraphList.end())
            {
                rootedGraphList.push_back(tempGraph);
                if (verbose)
                    std::cout << "ADDING ROOTED GRAPH TO LIST!\n";
                /// output g_temp to file
                char *s = ntog6(g_temp,this->MWords,this->N);
                g6File << s;
            }
            else
                if (verbose)
                    std::cout << "DUPLICATE! NOT ADDING TO LIST!\n";

        } /// loop over pairs

        if (verbose)
            std::cout << "At order " << this->N << " graph number " << count << " produced " << rootedGraphList.size() << " rooted graphs!\n";

    } /// while

    /// free nauty data structures
    DYNFREE(g, g_sz);
    DYNFREE(g_temp,g_temp_sz);
    DYNFREE(lab,lab_sz);
    DYNFREE(lab_cg,lab_cg_sz);
    DYNFREE(ptn,ptn_sz);
    DYNFREE(orbits,orbits_sz);

    free(c); /// free vertex colors

    fclose(fp); /// close input file
    g6File.close(); /// close output stream

}

/// given a selected pair vertices, produce a new relabeling
/// rooted vertices should be mapped to 0 and 1 respectively (start from zero!)
void GraphGeneratorNauty::ProduceNewLabelingGivenRootedVertices(const std::vector<int>& rooted, std::vector<int>& newLabeling, bool verbose)
{
    if (rooted.size()!=2)
        throw std::invalid_argument("ProduceNewLabelingGivenRootedVertices expects rooted to have two elements!\n");

    if (newLabeling.size()!=this->N)
        throw std::invalid_argument("ProduceNewLabelingGivenRootedVertices expects newLabeling to have N elements!\n");

    for (int i=0; i<newLabeling.size(); ++i)
        newLabeling[i] = i;

    if (rooted[0]==1 && rooted[1]==0) /// simply swap labels of two rooted vertices?
    {
        newLabeling[0] = 1;
        newLabeling[1] = 0;
    }
    else
    {
        if (rooted[0]!=0) /// does the first rooted vertex have the correct label? (0) Swap!
        {
            newLabeling[0] = rooted[0]; /// vertex 0 (which is in place) receives new label
            newLabeling[rooted[0]] = 0; /// relabel vertex of color 0 as number 0
        }

        if (rooted[1]!=1) /// does the second rooted vertex have the correct label? (1) Swap!
        {
            // find where in array "1" resides and swap places
            auto element = std::find(newLabeling.begin(), newLabeling.end(), 1);
            *element = newLabeling[rooted[1]]; /// vertex 1 receives new label
            newLabeling[rooted[1]] = 1; /// relabel vertex of color 1 as number 1
        }
    }

    if (verbose)
    {
        std::cout << "RELABELING: " << rooted[0] << " " << rooted[1] << "\n";
        for (int i=0; i<newLabeling.size(); ++i)
            std::cout << i << " maps to " << newLabeling[i] << "\n";
    }

}

/// got all pairs of vertices to be fixed for two-point function (labels start at zero!)
/// assumes we have N vertices
void GraphGeneratorNauty::GetAllPossiblePairsForRootedVertices()
{
    std::vector<int> tmp;
    std::vector<int> vertices(this->N);
    for (int i = 0; i<vertices.size(); ++i)
        vertices[i] = i;
    this->RootedVertexNumbers.clear(); /// clear list of fixed vertices
    this->GenerateUniqueCombinationsWithNoDuplicates(tmp, vertices, 2);
}

/// get all unique combinations of vertices without any duplicate entries using depth first search
void GraphGeneratorNauty::GenerateUniqueCombinationsWithNoDuplicates(std::vector<int>& tmp, const std::vector<int>& vertices, int k, bool verbose)
{
    if (k==0)
    {
        if (verbose)
        {
            std::cout << "ADDING_PAIR:";
            for (auto x:tmp)
                std::cout << " " << x;
            std::cout << std::endl;
        }
        this->RootedVertexNumbers.push_back(tmp);
        return;
    }

    for (int i=0; i<vertices.size(); ++i)
    {
        if (std::find(tmp.begin(), tmp.end(), vertices[i])==tmp.end())
        {
            tmp.push_back(vertices[i]);
            this->GenerateUniqueCombinationsWithNoDuplicates(tmp, vertices, k-1);
            tmp.pop_back();
        }
    }
}

/// wrapper for readg
graph* GraphGeneratorNauty::GetNextGraph(graph *g)
{
    return readg(this->fp,g,0,&this->MWords,&this->N);
}

/// process commmand line arguments using BOOST
bool GraphGeneratorParametersNauty::ProcessCommandLine(int argc, char *argv[])
{
    try
    {
        po::options_description desc("Allowed options");
        desc.add_options()
                ("help,h", "Produce help message")
                (",n", po::value<unsigned int>(&this->N)->required(), "Maximum vertex order")
                (",d", po::value<bool>(&this->Disconnected)->default_value(false), "Allow disconnected graphs?")
                (",r", po::value<bool>(&this->TwoRooted)->default_value(false), "Generate two-rooted graphs?")
                (",v", po::value<bool>(&this->Verbose)->default_value(false), "Verbose?")
                ;

        po::variables_map vm;
        po::store(po::parse_command_line(argc, argv, desc), vm);

        if (vm.count("help"))
        {
            std::cout << desc << "\n";
            return false;
        }

        po::notify(vm);
    }
    catch(std::exception& e)
    {
        std::cerr << "Error: " << e.what() << "\n";
        return false;
    }
    catch (...)
    {
        std::cerr << "Unknown error!" << "\n";
        return false;
    }
    return true;
}

/// constructor for user parameters wrapper class
GraphGeneratorParametersNauty::GraphGeneratorParametersNauty(int argc, char *argv[])
{
    if (this->ProcessCommandLine(argc, argv))
        std::cout << "Successfully parsed command line arguments!" << "\n";
    else
        std::exit(1);
}
